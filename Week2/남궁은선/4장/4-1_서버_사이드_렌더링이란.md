# 4.1 서버 사이드 렌더링이란?
- 왜 서버 사이드 렌더링이 최근에 각광받게 됐는지. 
- SPA의 한계로부터 다시 각광받고 있다. 

#### 싱글 페이지 애플리케이션이란?
- 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이뤄진다.
- 페이지를 불러온 이후에 서버에서 HTML을 내려받지 않고, 하나의 페이지에서 모든 작업을 처리하므로 싱글 페이지 애플리케이션 이라고 한다. 
- 사이트 렌더링에 필요한 <body/> 내부의 내용을 모두 자바스크립트 코드로 삽입한 후, 렌더링한다. 
- 페이지 전환 시에도 새로운 HTML 페이지를 요청하는게 아니라 다음 페이지의 렌더링에 필요한 정보만 HTTP요청 등으로 가져와, 결과를 바탕으로 <body/> 내부에 DOM을 추가 수정 삭제하는 방법으로 페이지가 전환된다. 
- 단점 : **최초에 로딩해 할 자바스크립트 리소스가 커진다.**
- 장점 : 한번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공하는게 가능하다.

#### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- 예전에는 대부분의 렌더링이 서버 사이드에서 이뤄졌다. 
- 자바스크립트를 모듈화하는 방안으로 등장한 것이 CommonJs와 AMD(Asynchronous Module Definition)
- 모듈화, 기기 성능향상, 인터넷 속도 발전으로, 자바스크립트에서 할 수 있는 일이 점차 다양해짐.
- 페이지의 렌더링~사용자의 인터랙션까지 모두 자바스크립트가 담당하면서 SPA 렌더링이 인기를 얻게 됨.

#### JAM 스택
- SPA 유행으로 JAM스택이 생겨남
- 기존엔 LAMP스택으로 구성. 대부분의 처리를 서버에서 해야만 했음. 
- 서버 의존적 문제는 확장성에 걸림돌이 됨. 
- 기능이 다양해지거나, 사용자가 늘어나면서 서버도 확장해야했지만, 당시에는 이것이 매우 번거로웠음. 
- 이로 인해 생겨난 것이 JAM.
- **마크업(HTML,CSS)를 미리 빌드해두고, 정적으로 사용자에게 제공하면 이후 작동은 사용자의 클라이언트에서 실행되므로 서버 확장성 문제에서 좀 더 자유로워짐.**

#### 새로운 패러다음의 웹서비스를 향한 요구
- 웹페이지를 불러오는 데 필요한 부담을 사용자에게 전가하더라도, 기기나, 인터넷 환경이 더 빠르게 발전할 것이기 때문에 괜찮을 것이라는 기대가 있었다. 
- 실제로 자바스크립트 리소스 크기, 스크립트가 페이지당 소비하는 CPU 시간, 웹페이지로딩속도, 등이 증가하였다. 
- 먼저 [자료로부터](https://httparchive.org/reports/loading-speed) 눈에 띄는 모습은 자바스크립트 파싱을 위해 CPU를 소비하는 시간이 눈에 띄게 증가 했다는 점이다. 
- 이 모든 것이 SPA의 탓이라는 건 아니다. 
- 그럼에도, **환경 개선에 비해, 웹애플리케이션 로딩속도는 크게 차이가 없거나 오히려 더 느리다는 점이 문제.**

## 4.1.2 서버 사이드 렌더링이란? 
- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식. 
- 웹페이지가 점점 느려지는 상황을 개선하고자 기존 방식의 웹개발이 다시금 떠오르고 있다. 
- 웹페이지의 렌더링을 서버에서 책임. 

### 서버 사이드 렌더링의 장점

**1. 최초 페이지 진입이 비교적 빠르다.**
- FCP(First Contentful Paint) 즉 최초 페이지에 진입했을 때, 유의미한 정보가 그려지는 시간이 더 빨라질 수 있다. 
- 만약 외부 API 호출에 많이 의지해야하는 화면이라면, API 호출 후 응답 결과를 가지고 렌더링을 서버에서 작업한다면 빠르게 렌더링이 가능하다. 
- 최초 그려야할 HTML 크기가 크거나 HTTP 요청에 의존적인 경우 서버 사이드 렌더링이 더 빠를 수 있다. 

**2. 검색 엔진관 SNS 공유 등 메타데이터 제공이 쉽다.**
- 검색 엔진 최적화에 유용하다.
> 검색 엔진이 사이트에서 필요한 정보를 가져가는 과정 
> 1. 검색 엔진 로봇에 페이지에 진입힌다.
> 2. 페이지가 HTML 정보를 제공해, 로봇이 HTML을 다운로드한다. 다운로드만 하고 자바스크립트 코드는 실행하지 않는다. 
> 3. 다운로드한 HTML 페이지 내부의 오픈그래프나 메타태그 정보를 기반으로 페이지의 검색(공유) 정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다. 


- 서버사이드 렌더링은 최초의 렌더링이 서버에서 일어나기 때문에, 검색엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있어 검색 엔진 최적화에 대응하기 용이하다. 

**3.  누적 레이아웃 이동이 적다.**
>누적 레이아웃 이동: 페이지를 보여준 이후, 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 화면이 덜컥이는 부정적인 사용자 경험 
- SPA는 페이지 콘텐츠가 API요청에 의존하고, API 요청의 응답속도가 제각각. 이를 처리하지 않으면 누적 레이아웃 이동 문제가 생김. 
- SSR을 사용한다 해도, useEffect를 사용하면, 컴포넌트가 마운트 된 이후에 실행되므로 모두 문제의 소지가 있다. 


**4.사용자의 디바이스 성능에 비교적 자유롭다**
- 그러나 서버부담이 가중될 수 있어, SSR도 충분히 느려질 수 있다. 

**5. 보안에 좀 더 안전하다**
- JAM 애플리케이션의 모든 활동이 브라우저에 노출된다. 
- 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다는 장점이 있다. 


### 단점
 1. 소스코드를 작성할 때 항상 서버를 고려해야한다. 
 - 브라우저 전역 객체는 브라우저에만 있다. window, localStorage등은 정의되어있지 않다. 
 2. 클라이언트에서만 실행되는 코드가 많아질수록, SSR 장점을 잃게된다. 

 3. 적절한 서버가 구축되어 있어야 한다. 
 4. 서비스 지연에 따른 문제
  - 서비스 지연이 일어날 때, 특히 다양한 요청에 얽혀있어 병목 현상이 심해지는 경우 SSR이 더 안좋은 사용자 경험을 제공할 수 있다.

> Q. 서버사이드에서의 지연로딩하는 방법은 없을까?

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유
### 서버 사이드 렌더링 역시 만능이 아니다. 
- 서버와 클라이언트 두군데로 관리포인트만 늘어나는 역효과를 낳을 수 있다.
- 웹페이지에서 제공하고싶은 내용, 내용의 우선순위에 따라 잘 설계해야함. 
- 웹페이지 설계 목적, 우선순위 따라 SPA가 더 효율적일 수 있다. 

### SPA와 SSRA

#### SPA와 MPA에 대한 비교
1. 가장 뛰어난 SPA는 가장 뛰어난 MPA보다 낫다.

    SPA는 게으른 로딩으로 렌더링에 방해되지 않도록 처리, 코드분할(필요한 코드만 나눠서 번들링하는 기법)등을 모두 지켜 불필요한 자바스크립트 리소스의 다운로드 및 실행을 방지해둔다면, 이에 비해 모든 최적화를 처리한 MPA는 SPA를 따라갈 수 없다. 

2. 평균적 SPA는 평균적 MPA보다 느리다. 
- MPA는 매번 서버에 요청을 하고, 안정적인 리소스를 기반으로 매 요청마다 비슷한 성능의 렌더링을 수행한다. 
- 반면 SPA는 페이지 전환 시 필요한 리소스와, 공통으로 사용하는 리소스로 분류하고, 이에 따른 다운로드나, 렌더링 우선순위 전략을 잘 수립해 서비스하기란 매우 어렵다. 
- 평균적인 노력을 기울여 동일한 서비스를 만든다면, MPA가 더 우위에 있을 수 있다. 
- 최근 MPA에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 API가 브라우저에 추가되고있다. 
    >- [페인트홀딩](https://developer.chrome.com/blog/paint-holding?hl=ko) : 같은 출처에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
    >- [back forward cache(bfcache)](https://web.dev/articles/bfcache?hl=ko): 브라우저 앞,뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
    >- Shared Element Transitions : 페이지 라우팅 시 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법
    >

    이것들은 모두 SPA서 구현 가능한 것이지만, 완벽하게 구현하려면 상당한 노력을 기울여야하므로 MPA 승. 


- 위의 내용들은 상황에 따라 유효한 방법
- SPA가 제공하는 보일러플레이트나 라이브러리가 점차 완벽해지며 잠재적 모든 위험을 제거할 수 있고
- MPA가 브라우저 API의 도움을 받아 SPA와 같은 사용자 경험을 제공할 수도 있다. 

